#!/usr/bin/env bash
# Copyright (C) 2021 Torbjorn Sjostrand.
# PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.
# Please respect the MCnet Guidelines, see GUIDELINES for details.

# Script to run tests sequentially over commits. Example usage is:
#     ./testgit --ref=ee355a75
# or to print the help:
#     ./testgit --help

################################################################################
# VARIABLES: Global variables not defined via command line arguments.
#     USAGE:   Text printed when the --help option is passed.
#     OPTIONS: Available user options.
################################################################################
read -d "" USAGE << "BLOCKTEXT"
Usage: ./testgit [OPTION]

Run tests sequentially over commits in Git. The available options are
defined below. Arguments to the options are indicated in caps,
e.g. HASH.

Configuration options.
--help          : Print this message (also -h, --h, and -help).
--ref=HASH      : Reference commit for testing the tree, defaults to the 
                  first commit in the tree. If PREVIOUS is passed as HASH,
                  then each commit is compared to the previous.
--first=HASH    : Hash for the first commit to test, defaults to the first
                  commit in the tree.
--last=HASH     : Hash for the last commit to test, defaults to the last 
                  commit in the tree.
--parents       : Flag to follow only the parents of LAST.
--reverse       : Flag to reverse the order of commits.
--list          : List the indexed commits and exit.
--skip          : Skip commits with all failed tests.
--patch=HASH    : Set up the directories "old" and "new" in the current 
                  directory for patching the commit HASH. If no argument, 
                  create a patch from these directories in DIF.
                  If HASH is provided in the form HASH1/HASH2 then a patch
                  is created that transforms HASH2 into HASH1.
--force         : Flag to force removing a test cache and rerunning tests.
--debug=LEVEL   : Debug level, 0 (low) to 2 (high) [0].
--flags=FLAGS   : Flags to pass when building, ["-j6"].
--branch=BRANCH : Branch on which to run the tests [master].
--clone=CLONE   : Repository to clone [git@gitlab.com:Pythia8/pythia83.git].
--local=LOCAL   : Local repository (removed before each commit test) [repo].
--cache=CACHE   : Cached repository [.cache].
--difdir=DIF    : Directory where patches are stored [patches].
--outdir=OUT    : Directory to store the output [commits].
--log=LOG       : Logfile to store the difference summaries [testsums.log].
BLOCKTEXT
OPTIONS="-h --h -help --ref --first --last --parents --reverse --list"
OPTIONS+=" --skip --patch --force --debug --flags --branch --clone --local"
OPTIONS+=" --cache --difdir --outdir --log"

################################################################################
# FUNCTION: Print warning message.
################################################################################
function warn() {
    if ! type "tput" &> /dev/null; then echo -e $@
    else echo -e $(tput setaf 0)$(tput setab 3)WARNING: $@$(tput sgr0); fi
}

################################################################################
# FUNCTION: Find the output directory (ordered as $IDX.$HASH, $HASH, *.$HASH).
################################################################################
function findout() {
    local OUT=$OUTDIR/$1
    if [ -d $OUT ]; then echo $OUT; return; fi
    local OUT=$OUTDIR/$2
    if [ -d $OUT ]; then echo $OUT; return; fi
    for OUT in $OUTDIR/*.$2; do
	if [ -d $OUT ]; then echo $OUT; return; fi;
    done
    echo $OUTDIR/$1
}

################################################################################
# FUNCTION: Find the patch file (same ordering as findout).
################################################################################
function finddif() {
    local DIF=$DIFDIR/$1.dif
    if [ -f $DIF ]; then echo $DIF; return; fi
    local DIF=$DIFDIR/$2.dif
    if [ -f $DIF ]; then echo $DIF; return; fi
    for DIF in $DIFDIR/*.$2.dif; do
	if [ -f $DIF ]; then echo $DIF; return; fi
    done
    echo $3
}

################################################################################
# FUNCTION: Retrieve the index, label, output, and patch for a commit.
################################################################################
function retrieve() {
    eval IDX=\${IDX${1}}; eval LBL=\${LBL${1}}
    eval OUT=\${OUT${1}}; eval DIF=\${DIF${1}}
}

################################################################################
# FUNCTION: Build and test for a given commit, patch, and output directory.
################################################################################
function build() {
    rm -rf $LOCAL
    cp -r $CACHE $LOCAL
    cd $LOCAL
    git reset --hard $1
    TESTDIR=private/tests
    mkdir -p $TESTDIR
    cp $CACHE/$TESTDIR/* $LOCAL/$TESTDIR
    if [ ! -z $PATCH ]; then cp -rf $LOCAL $OLD; fi
    if [ ! -z $3 ]; then
	echo "patch -p1 < $3" > $LOCAL/patch.log
	patch -p1 < $3 2>&1 | tee -a $LOCAL/patch.log 2>&4
    fi
    if [ ! -z $PATCH ]; then cp -rf $LOCAL $NEW; return; fi
    make $FLAGS 2>&1 | tee $LOCAL/build.log
    cd $TESTDIR
    make $FLAGS check 2>&1 | tee $LOCAL/tests.log
    make checkdir 2>&1 | tee -a $LOCAL/tests.log
    mkdir -p $2
    cp cmp/* $2/
    for STR in "patch" "build" "tests"; do mv $LOCAL/$STR.log $2/$STR.log; done
}

################################################################################
# MAIN: The main execution of the runmains script.
################################################################################

# Check if help requested.
for VAR in "$@"; do
    if [[ "$VAR" = "-h" || "$VAR" = "--h" || "$VAR" = "-help" \
	  || "$VAR" = "--help" ]]; then
	echo -e "$USAGE"
	exit
    fi
done

# Parse the user arguments and evaluate each as a global variable.
for VAR in "$@"; do
    if ! [[ $OPTIONS =~ (^| )${VAR%%=*}($| ) ]]; then
	warn "Ignoring invalid option \"${VAR%=*}\".";
	continue;
    fi
    VAR=${VAR#--};
    KEY=${VAR%%=*}; VAL=${VAR#$KEY}; VAL=${VAL#*=}; KEY=${KEY//"-"/"_"}
    KEY=$(echo $KEY | awk '{print(toupper($0))}');  VAL=$(eval echo $VAL)
    eval $KEY=\"$VAL\"; eval ${KEY}_SET=true
done

# Default options.
if [ -z $FLAGS ];  then FLAGS="-j2"; fi
if [ -z $DEBUG ];  then DEBUG=0; fi
if [ -z $BRANCH ]; then BRANCH="master"; fi
if [ -z $CLONE ];  then CLONE="git@gitlab.com:Pythia8/pythia83.git"; fi
if [ -z $LOCAL ];  then LOCAL="repo"; fi
if [ -z $CACHE ];  then CACHE=".cache"; fi
if [ -z $DIFDIR ]; then DIFDIR="patches"; fi
if [ -z $OUTDIR ]; then OUTDIR="commits"; fi
if [ -z $LOG ];    then LOG="testsums.log"; fi

# Get full directory paths.
LOCAL=$(readlink -f $LOCAL)
CACHE=$(readlink -f $CACHE)
DIFDIR=$(readlink -f $DIFDIR)
OUTDIR=$(readlink -f $OUTDIR)
TOPDIR=$(pwd)
LOG=$(readlink -f $LOG)

# Set the verbosity level.
exec 3>&1; exec 4>&2
if [ "$DEBUG" -eq 0 ]; then exec 1>/dev/null; exec 2>/dev/null
elif [ "$DEBUG" -eq 1 ]; then exec 1>/dev/null; fi

# Cache the Pythia repository.
if [ ! -d $CACHE ]; then git clone $CLONE $CACHE; fi

# Start from a clean local repository.
if [ ! -f testsum ]; then TESTSUM=$(readlink -f $CACHE/private/tests/testsum)
else TESTSUM=$(readlink -f testsum); fi

# Build the hash dictionary.
mkdir -p $OUTDIR
rm -rf $LOCAL
cp -r $CACHE $LOCAL
cd $LOCAL
git checkout $BRANCH
IDX=0
GIT="git log --pretty=%H"
PAD=$($GIT | cat -n | tail -n 1 | awk '{print($1)}')
PAD=$((${#PAD} + 1))
for COMMIT in $($GIT --reverse); do
    if [ -z $REF ]; then REF=$COMMIT; fi
    if [ -z $FIRST ]; then FIRST=$COMMIT; fi 
    HASH=${COMMIT:0:8}
    LBL=$(printf %0${PAD}i $IDX).$HASH
    OUT=$(findout $LBL $HASH)
    DIF=$(finddif $LBL $HASH $DIF)
    eval IDX${COMMIT}=$IDX; eval LBL${COMMIT}=$LBL
    eval OUT${COMMIT}=$OUT; eval DIF${COMMIT}=$DIF
    if [ "$LIST_SET" == "true" ]; then echo $LBL 1>&3 2>&4; fi
    IDX=$((IDX+1))
done
if [ "$LIST_SET" == "true" ]; then exit; fi
if [ -z $LAST ]; then LAST=$COMMIT; fi
echo "Processed $IDX commits on '$BRANCH'." 1>&3 2>&4

# Determine the full hashes and commits to test.
if [ "$REF" == "PREVIOUS" ]; then
    IDXREF=$REF
else
    REF=$($GIT -n 1 $REF)
    eval IDXREF=\${IDX${REF}}
    eval OUTREF=\${OUT${REF}}; fi
FIRST=$($GIT -n 1 $FIRST)
eval IDXFIRST=\${IDX${FIRST}}
LAST=$($GIT -n 1 $LAST)
eval IDXLAST=\${IDX${LAST}}
if [ "$REVERSE_SET" != "true" ]; then GIT+=" --reverse"; fi
if [ "$PARENTS_SET" == "true" ]; then GIT+=" $LAST"; fi 

# Create directories for patching or create the patch.
OLD=$TOPDIR/old; NEW=$TOPDIR/new; TMP=$TOPDIR/tmp;
if [ ! -z $PATCH ]; then
    PATCH1=${PATCH%/*};           PATCH2=${PATCH#*/}
    COMMIT1=$($GIT -n 1 $PATCH1); COMMIT2=$($GIT -n 1 $PATCH2)
    retrieve $COMMIT1

    # Patch a single commit.
    echo "Patching $LBL." 1>&3 2>&4
    build $COMMIT1 $OUT $DIF
    echo $LBL > $NEW/label.log
    
    # Patch between two commits.
    if [ "$COMMIT1" != "$COMMIT2" ]; then
	mv $NEW $TMP; rm -rf $OLD
	retrieve $COMMIT2
	build $COMMIT2 $OUT $DIF
	rm -rf $NEW; mv $TMP $NEW
	DIF=$DIFDIR/$LBL.dif
	echo "Creating $DIF." 1>&3 2>&4; cd $TOPDIR
	diff -rupNx '*.log' -x *.orig -x *.rej -x *~ -x .git old new > $DIF
    fi
    exit
elif [ "$PATCH_SET" == "true" ]; then
    DIF=$DIFDIR/$(cat $NEW/label.log).dif
    echo "Creating $DIF." 1>&3 2>&4; cd $TOPDIR
    diff -rupNx '*.log' -x *.orig -x *.rej -x *~ -x .git old new > $DIF
    exit
fi
    
# Loop over the commits.
if [ $IDXFIRST -gt $IDXLAST ]; then
    IDX=$IDXFIRST; IDXFIRST=$IDXLAST; IDXLAST=$IDX; fi
echo "Testing between $IDXFIRST and $IDXLAST against $IDXREF." 1>&3 2>&4
echo -e $0 $@ "\n" > $LOG
for COMMIT in $($GIT); do
    retrieve $COMMIT
    if [[ "$COMMIT" == "$REF" || \
	  ($IDX -ge $IDXFIRST && $IDX -le $IDXLAST) ]]; then
	echo $LBL 1>&3 2>&4
	if [[ "$FORCE_SET" == "true" || ! -d $OUT ]]; then
	    build $COMMIT $OUT $DIF
	fi
	if [ "$SKIP_SET" == "true" ]; then
	    FAIL=true
	    for DAT in $OUT/*.dat; do
		if [ -f $DAT ]; then FAIL=false; break; fi
	    done
	    if [ "$FAIL" == "true" ]; then continue; fi
	fi
	cd $OUT
	if [ -z "$OUTREF" ]; then OUTREF=$OUT; fi
	$TESTSUM -d $OUTREF > testsum.log
	if [ "$REF" == "PREVIOUS" ]; then OUTREF=$OUT; fi
	echo $LBL >> $LOG
	tail -n 4 testsum.log >> $LOG
	echo >> $LOG
    fi
done
